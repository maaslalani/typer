package typer

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io"
	"math/rand"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/charmbracelet/bubbles/progress"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/maaslalani/typer/pkg/flags"
	"github.com/maaslalani/typer/pkg/model"
	"github.com/maaslalani/typer/pkg/theme"
	util "github.com/maaslalani/typer/pkg/utility"
	wrap "github.com/mitchellh/go-wordwrap"
	"github.com/spf13/viper"
)

const (
	words        = 15
	defaultWidth = 60
)

// FromStdin takes input text from stdin
func FromStdin(n int, flagStruct *flags.Flags) error {
	var stdin []byte
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		stdin = append(stdin, scanner.Bytes()...)
	}

	if err := scanner.Err(); err != nil {
		return err
	}

	text := string(stdin)
	text, err := flagStruct.FormatWords(text)
	if err != nil {
		return err
	}

	return run(text)
}

// FromRandom runs the app with text generated by RandomWords
func FromRandom(n int, flagStruct *flags.Flags) error {
	text := util.RandomWords(n)

	text, err := flagStruct.FormatWords(text)
	if err != nil {
		return err
	}

	return run(text)
}

// FromFile runs the app with text extracted from a file
func FromFile(path string, flagStruct *flags.Flags) error {
	text, err := util.ReadFile(path)
	if err != nil {
		return err
	}

	text, err = flagStruct.FormatWords(text)
	if err != nil {
		return err
	}

	return run(text)
}

func FromMonkeytype(language string, flagStruct *flags.Flags) error {
	if language == "" {
		language = "english"
	}

	textType := "languages"
	if flagStruct.Quote {
		textType = "quotes"
	}

	resp, err := http.Get(fmt.Sprintf("https://raw.githubusercontent.com/monkeytypegame/monkeytype/master/frontend/static/%s/%s.json", textType, language))
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return fmt.Errorf("error while fetching language (code %d)", resp.StatusCode)
	}

	bodyBytes, err := io.ReadAll(resp.Body)

	if err != nil {
		return err
	}

	var formatted string
	if !flagStruct.Quote {
		words := struct {
			Words []string `json:"words"`
		}{}
		if err := json.Unmarshal(bodyBytes, &words); err != nil {
			return err
		}

		seed := rand.NewSource(time.Now().Unix() + int64(len(words.Words)))
		r := rand.New(seed)
		r.Shuffle(len(words.Words), func(i, j int) {
			words.Words[i], words.Words[j] = words.Words[j], words.Words[i]
		})

		formatted, err = flagStruct.FormatWords(strings.Join(words.Words, "\n"))
		if err != nil {
			return err
		}
	} else {
		quotes := struct {
			Quotes []flags.Quote `json:"quotes"`
		}{}
		if err := json.Unmarshal(bodyBytes, &quotes); err != nil {
			return err
		}

		formatted, err = flagStruct.FormatQuote(quotes)
		if err != nil {
			return err
		}
	}

	return run(formatted)
}

// run is responsible for running the GUI
func run(text string) error {
	currentTheme, err := theme.LoadViper(viper.GetViper(), true)
	if err != nil {
		return err
	}

	bar, err := progress.NewModel(currentTheme.BarColor())
	if err != nil {
		return err
	}

	program := tea.NewProgram(model.Model{
		Progress: bar,
		Text:     []rune(wrap.WrapString(text, defaultWidth)),
		Theme:    currentTheme,
	})

	return program.Start()
}
